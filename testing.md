# Тестирование

Все публичные методы должны быть покрыты модульными тестами. 
Как говорится, "доверяй, но проверяй" - лучше один модульный тест на метод, чем тысяча заверений в его работоспособности. 
В требовании писать модульные тесты мы исходим из экономической эффективности. 
Написание теста занимает 10 минут, а обнаружение бага тестировщиком, заведение задачи и последующее устранение бага разработчиком может занимать от часа и более. 
Поэтому мы пишем модульные тесты.

## Три этапа тестирования

Каждый тест состоит из трёх этапов:

1. Подготовка данных.
2. Тестирование проверяемой функциональности.
3. Проверка полученных результатов.

Пример теста, со всеми тремя этапами тестирования функциональности:

```kotlin
@Test
fun delete() {
    entityGenerator.insertCalculationType(domain.id!!) //подготовка тестовых данных
        .also {
            calculationTypeService.delete(it.id!!) //тестирование проверяемой функциональности
            assertThrows(NoSuchElementException::class.java) { calculationTypeService.get(it.id!!) } //проверка полученных результатов
        }
}
```

## Profile или Mockito?

В тех случаях, когда требуется описать нестандартное поведение какого-то сервиса, мы создаём бины-наследники основного интерфейса с нестандартным поведением. 
Например, у нас существует интерфейс `UserService`. 
Основной бин, в котором содержится ожидаемая логика поведения - `UserServiceImpl`. 
Бин, в котором описана негативная логика (например, выбрасываются исключения), будет называться `UserServiceNegative`, при этом, поскольку бин тестовый, он содержится в тестовом модуле. 
Инициализация тех или иных бинов управляется через профили. 
Использование библиотеки Mockito не приветствуется, поскольку при таком подходе поведение одного бина описывается в другом.

